
  const pushHistory = useCallback(() => {
    const c = fcRef.current; if (!c) return;
    const json = JSON.stringify(c.toJSON(['_isBgImage','_isSafeZone','_isGuideLine','_isGuideText','_isSizeLabel','_isBgPattern','selectable','evented','name']));
    const arr = historyRef.current;
    if (historyIdxRef.current < arr.length - 1) arr.splice(historyIdxRef.current + 1);
    arr.push(json); if (arr.length > 50) arr.shift();
    historyIdxRef.current = arr.length - 1; setHistoryIdx(historyIdxRef.current);
  }, []);

  const undo = useCallback(() => { const c = fcRef.current; if (!c||historyIdxRef.current<=0) return; historyIdxRef.current--; loadingRef.current=true; c.loadFromJSON(JSON.parse(historyRef.current[historyIdxRef.current])).then(()=>{ c.getObjects().forEach((o:any)=>{if(o.name==='__bgImage__'){o._isBgImage=true;o.set({selectable:false,evented:false})}}); c.renderAll(); loadingRef.current=false; refreshLayers(); setHistoryIdx(historyIdxRef.current); }); }, [refreshLayers]);
  const redo = useCallback(() => { const c = fcRef.current; if (!c||historyIdxRef.current>=historyRef.current.length-1) return; historyIdxRef.current++; loadingRef.current=true; c.loadFromJSON(JSON.parse(historyRef.current[historyIdxRef.current])).then(()=>{ c.getObjects().forEach((o:any)=>{if(o.name==='__bgImage__'){o._isBgImage=true;o.set({selectable:false,evented:false})}}); c.renderAll(); loadingRef.current=false; refreshLayers(); setHistoryIdx(historyIdxRef.current); }); }, [refreshLayers]);

  const del = useCallback(() => { const c = fcRef.current; if (!c) return; const obj = c.getActiveObject(); if (obj && obj.selectable!==false) { if (obj.type==='activeselection') { const ch=(obj as any)._objects||[]; c.discardActiveObject(); ch.forEach((o:any)=>{if(o.selectable!==false)c.remove(o)}); c.renderAll(); refreshLayers(); } else { c.remove(obj); c.discardActiveObject(); c.renderAll(); } } }, []);

  const handleExport = useCallback((format: 'png'|'svg'|'pdf') => {
    const c = fcRef.current; if (!c) return;
    const guides:any[] = []; c.getObjects().forEach((o:any)=>{if(o._isSafeZone||o._isGuideLine||o._isGuideText||o._isSizeLabel||o._isBgPattern) guides.push(o)}); guides.forEach(g=>c.remove(g)); c.renderAll();
    if (format==='png') { const d=c.toDataURL({format:'png',multiplier:exportScale}); const a=document.createElement('a'); a.download=panelId+'_'+exportScale+'x.png'; a.href=d; a.click(); }
    else if (format==='svg') { const s=c.toSVG(); const b=new Blob([s],{type:'image/svg+xml'}); const u=URL.createObjectURL(b); const a=document.createElement('a'); a.download=panelId+'.svg'; a.href=u; a.click(); URL.revokeObjectURL(u); }
    else if (format==='pdf') { const d=c.toDataURL({format:'png',multiplier:exportScale}); const w=c.getWidth()*exportScale; const h=c.getHeight()*exportScale; import('jspdf').then(({jsPDF})=>{ const pdf=new jsPDF({orientation:w>h?'landscape':'portrait',unit:'px',format:[w,h]}); pdf.addImage(d,'PNG',0,0,w,h); pdf.save(panelId+'.pdf'); }).catch(()=>alert('PDF requires jspdf')); }
    guides.forEach(g=>c.add(g)); c.renderAll();
  }, [panelId, exportScale]);

  const handleSavePanel = useCallback(() => {
    const c = fcRef.current; if (!c) return;
    const json = JSON.stringify(c.toJSON(['_isBgImage','_isSafeZone','_isGuideLine','_isGuideText','_isSizeLabel','_isBgPattern','selectable','evented','name']));
    const guides:any[] = []; c.getObjects().forEach((o:any)=>{if(o._isSafeZone||o._isGuideLine||o._isGuideText||o._isSizeLabel) guides.push(o)}); guides.forEach(g=>c.remove(g)); c.renderAll();
    const thumb = c.toDataURL({format:'png',multiplier:0.3});
    guides.forEach(g=>c.add(g)); c.renderAll();
    onSave(panelId, json, thumb);
  }, [panelId, onSave]);

  const addText = useCallback((content?: string, opts?: any) => {
    const c = fcRef.current; if (!c) return; const { IText } = require('fabric');
    const t = new IText(content||'Text', { left:c.getWidth()/2-30, top:c.getHeight()/2-15, fontSize:opts?.fontSize||fSize, fill:opts?.fill||color, fontFamily:opts?.fontFamily||selectedFont, ...opts });
    c.add(t); c.setActiveObject(t); c.renderAll(); refreshLayers();
  }, [fSize, color, selectedFont, refreshLayers]);

  const addShape = useCallback((type: string) => {
    const c = fcRef.current; if (!c) return;
    const { Rect, Circle, Triangle, Line:FL, Polygon, Ellipse } = require('fabric');
    const cx=c.getWidth()/2, cy=c.getHeight()/2; let s:any;
    if (type==='rect') s=new Rect({left:cx-40,top:cy-30,width:80,height:60,fill:color});
    else if (type==='roundrect') s=new Rect({left:cx-40,top:cy-30,width:80,height:60,fill:color,rx:10,ry:10});
    else if (type==='circle') s=new Circle({left:cx-30,top:cy-30,radius:30,fill:color});
    else if (type==='ellipse') s=new Ellipse({left:cx-30,top:cy-20,rx:40,ry:25,fill:color});
    else if (type==='triangle') s=new Triangle({left:cx-30,top:cy-30,width:60,height:60,fill:color});
    else if (type==='line') s=new FL([cx-40,cy,cx+40,cy],{stroke:color,strokeWidth:3,fill:''});
    else if (type==='dashed') s=new FL([cx-40,cy,cx+40,cy],{stroke:color,strokeWidth:3,strokeDashArray:[10,5],fill:''});
    else if (type==='dotted') s=new FL([cx-40,cy,cx+40,cy],{stroke:color,strokeWidth:3,strokeDashArray:[2,4],fill:''});
    else if (type==='diamond') { const r=30; s=new Polygon([{x:cx,y:cy-r},{x:cx+r,y:cy},{x:cx,y:cy+r},{x:cx-r,y:cy}],{fill:color}); }
    else if (type==='star') { const pts:{x:number;y:number}[]=[]; for(let i=0;i<10;i++){const r=i%2===0?30:15; const a=(Math.PI/2*3)+(i*Math.PI/5); pts.push({x:cx+Math.cos(a)*r,y:cy+Math.sin(a)*r});} s=new Polygon(pts,{fill:color}); }
    else if (type==='pentagon') { const pts:{x:number;y:number}[]=[]; for(let i=0;i<5;i++){const a=(Math.PI/2*3)+(i*2*Math.PI/5); pts.push({x:cx+Math.cos(a)*30,y:cy+Math.sin(a)*30});} s=new Polygon(pts,{fill:color}); }
    else if (type==='hexagon') { const pts:{x:number;y:number}[]=[]; for(let i=0;i<6;i++){const a=i*Math.PI/3; pts.push({x:cx+Math.cos(a)*30,y:cy+Math.sin(a)*30});} s=new Polygon(pts,{fill:color}); }
    else if (type==='cross') { s=new Polygon([{x:cx-10,y:cy-30},{x:cx+10,y:cy-30},{x:cx+10,y:cy-10},{x:cx+30,y:cy-10},{x:cx+30,y:cy+10},{x:cx+10,y:cy+10},{x:cx+10,y:cy+30},{x:cx-10,y:cy+30},{x:cx-10,y:cy+10},{x:cx-30,y:cy+10},{x:cx-30,y:cy-10},{x:cx-10,y:cy-10}],{fill:color}); }
    else if (type==='arrow') s=new FL([cx-40,cy,cx+40,cy],{stroke:color,strokeWidth:3,fill:''});
    if (s) { c.add(s); c.setActiveObject(s); c.renderAll(); refreshLayers(); }
  }, [color, refreshLayers]);

  const addImage = useCallback(() => { fileRef.current?.click(); }, []);
  const onFileChange = useCallback(async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file=e.target.files?.[0]; if(!file) return; const c=fcRef.current; if(!c) return;
    const reader = new FileReader();
    reader.onload = async () => { const { FabricImage } = await import('fabric'); const img = await FabricImage.fromURL(reader.result as string); const sc=Math.min(c.getWidth()*0.8/(img.width||1),c.getHeight()*0.8/(img.height||1),1); img.set({left:50,top:50,scaleX:sc,scaleY:sc}); c.add(img); c.setActiveObject(img); c.renderAll(); refreshLayers(); };
    reader.readAsDataURL(file); e.target.value='';
  }, [refreshLayers]);

  const toggleDraw = useCallback(() => { const c=fcRef.current; if(!c) return; if(drawMode){c.isDrawingMode=false;setDrawMode(false);} else {c.isDrawingMode=true;c.freeDrawingBrush.color=color;c.freeDrawingBrush.width=brushSize;setDrawMode(true);setEraserMode(false);} }, [drawMode,color,brushSize]);
  const toggleEraser = useCallback(() => { const c=fcRef.current; if(!c) return; if(eraserMode){c.isDrawingMode=false;setEraserMode(false);} else {c.isDrawingMode=true;c.freeDrawingBrush.color='#ffffff';c.freeDrawingBrush.width=eraserSize;setEraserMode(true);setDrawMode(false);} }, [eraserMode,eraserSize]);

  const handleAiCopy = useCallback(async () => {
    if (!copyProduct.trim()) return; setCopyLoading(true); setCopyResult(null);
    try { const r=await fetch('/api/ai/generate-copy',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({productName:copyProduct,brandName:copyBrand||undefined})}); const d=await r.json(); if(d.error) throw new Error(d.error); setCopyResult(d); } catch(e:any) { alert('AI Copy: '+e.message); }
    setCopyLoading(false);
  }, [copyProduct, copyBrand]);

  const handleAiReview = useCallback(async () => {
    const c=fcRef.current; if(!c) return; setReviewLoading(true); setReviewResult(null);
    try { const d=c.toDataURL({format:'png',multiplier:1}); const r=await fetch('/api/ai/review-design',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({imageData:d})}); const data=await r.json(); if(data.error) throw new Error(data.error); setReviewResult(data); } catch(e:any) { alert('AI Review: '+e.message); }
    setReviewLoading(false);
  }, []);

  const handleAiInspire = useCallback(async () => {
    if(!inspirePrompt.trim()) return; setInspireLoading(true); setInspireImage(null);
    try { const r=await fetch('/api/ai/generate-design',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({prompt:inspirePrompt,boxType:panelName,width:widthMM,height:heightMM})}); const d=await r.json(); if(d.error) throw new Error(d.error); setInspireImage(d.imageUrl||d.url); } catch(e:any) { alert('AI: '+e.message); }
    setInspireLoading(false);
  }, [inspirePrompt, panelName, widthMM, heightMM]);

  const applyInspireToCanvas = useCallback(async () => {
    if(!inspireImage) return; const c=fcRef.current; if(!c) return;
    const { FabricImage } = await import('fabric'); const img = await FabricImage.fromURL(inspireImage);
    const sc=Math.min(c.getWidth()*0.9/(img.width||1),c.getHeight()*0.9/(img.height||1),1);
    img.set({left:c.getWidth()/2,top:c.getHeight()/2,originX:'center',originY:'center',scaleX:sc,scaleY:sc});
    c.add(img); c.setActiveObject(img); c.renderAll(); refreshLayers();
  }, [inspireImage, refreshLayers]);

  const applyCopyToCanvas = useCallback((field:string, value:string) => {
    const c=fcRef.current; if(!c) return; const { IText } = require('fabric');
    const sz:Record<string,number>={headline:28,description:16,slogan:20,features:14,backPanel:12};
    const t=new IText(value,{left:c.getWidth()/2,top:c.getHeight()/2,originX:'center',originY:'center',fontSize:sz[field]||16,fill:'#000',fontFamily:selectedFont});
    c.add(t); c.setActiveObject(t); c.renderAll(); refreshLayers();
  }, [selectedFont, refreshLayers]);

  const applyTemplate = useCallback(async (tpl: DesignTemplate) => {
    const c=fcRef.current; if(!c) return; setTemplateLoading(tpl.id);
    const F = require('fabric');
    const objs = await tpl.objects(F, c.getWidth(), c.getHeight());
    c.getObjects().filter((o:any)=>o.selectable!==false||o._isBgImage).forEach((o:any)=>{if(!o._isSafeZone&&!o._isGuideLine&&!o._isGuideText&&!o._isSizeLabel)c.remove(o)});
    objs.forEach((o:any)=>c.add(o)); c.renderAll(); refreshLayers(); pushHistory(); setTemplateLoading(null);
  }, [refreshLayers]);

  const handleBgUpload = useCallback(async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file=e.target.files?.[0]; if(!file) return; const c=fcRef.current; if(!c) return;
    const reader = new FileReader();
    reader.onload = async () => { const { FabricImage } = await import('fabric'); const img = await FabricImage.fromURL(reader.result as string); img.set({left:0,top:0,originX:'left',originY:'top',scaleX:c.getWidth()/(img.width||1),scaleY:c.getHeight()/(img.height||1),selectable:false,evented:false,name:'__bgImage__'}); (img as any)._isBgImage=true; c.getObjects().filter((o:any)=>o._isBgImage&&o!==img).forEach((o:any)=>c.remove(o)); c.add(img); c.sendObjectToBack(img); c.getObjects().filter((o:any)=>o._isSafeZone||o._isGuideText||o._isSizeLabel).forEach((o:any)=>c.sendObjectToBack(o)); c.renderAll(); refreshLayers(); };
    reader.readAsDataURL(file); e.target.value='';
  }, [refreshLayers]);
  const removeBg = useCallback(() => { const c=fcRef.current; if(!c) return; c.getObjects().filter((o:any)=>o._isBgImage).forEach((o:any)=>c.remove(o)); c.renderAll(); refreshLayers(); }, [refreshLayers]);

  const handleSaveDesign = useCallback(() => {
    const c=fcRef.current; if(!c) return;
    const json=c.toJSON(['_isBgImage','_isSafeZone','_isGuideLine','_isGuideText','_isSizeLabel','_isBgPattern','selectable','evented','name']);
    const b=new Blob([JSON.stringify(json,null,2)],{type:'application/json'}); const u=URL.createObjectURL(b); const a=document.createElement('a'); a.href=u; a.download=panelId+'_design.json'; a.click(); URL.revokeObjectURL(u);
  }, [panelId]);

  const handleLoadDesign = useCallback(() => {
    const inp=document.createElement('input'); inp.type='file'; inp.accept='.json';
    inp.onchange = async (e:any) => { const file=e.target.files?.[0]; if(!file) return; const reader=new FileReader(); reader.onload=async()=>{ try { const json=JSON.parse(reader.result as string); const c=fcRef.current; if(!c) return; await c.loadFromJSON(json); c.getObjects().forEach((o:any)=>{if(o.name==='__bgImage__'){o._isBgImage=true;o.set({selectable:false,evented:false})}}); c.renderAll(); refreshLayers(); pushHistory(); } catch{alert('Load failed')} }; reader.readAsText(file); };
    inp.click();
  }, [refreshLayers]);
