              });

              addSafeZone();
              didRestore = true;
            }
          }
        }
      } catch (e) { console.warn('auto-save restore failed', e); }

      if (!didRestore && savedJSON) {
        try {
          const parsed = typeof savedJSON === 'string' ? JSON.parse(savedJSON) : savedJSON;
          if (parsed && parsed.objects) {
            parsed.objects = parsed.objects.filter((obj: any) => {
              if (obj._isSafeZone || obj._isGuideLine || obj._isGuideText || obj._isSizeLabel) return false;
              if (obj.selectable === false && obj.evented === false && !obj._isBgImage && obj.name !== '__bgImage__') return false;
              if (obj.type === 'rect' && obj.stroke === '#93B5F7' && obj.fill === 'transparent') return false;
              if (obj.type === 'text' && (obj.fill === '#C0C0C0' || obj.fill === '#B0B0B0') && obj.fontSize <= 13 && obj.selectable === false) return false;
              if (obj.type === 'image' && obj.src && (obj.src.startsWith('blob:') || obj.src.startsWith('object:'))) return false;
              return true;
            });
            await canvas.loadFromJSON(parsed);
            canvas.getObjects().forEach((o: any) => { if (o.name === '__bgImage__') { o._isBgImage = true; o.set({ selectable: false, evented: false }); } });
            canvas.requestRenderAll();
            canvas.getObjects().filter((o: any) => {
              if (o._isBgImage || o.name === '__bgImage__') return false;
              if (o._isSafeZone || o._isGuideLine || o._isGuideText || o._isSizeLabel) return true;
              if (o.type === 'rect' && o.stroke === '#93B5F7' && o.fill === 'transparent') return true;
              return false;
            }).forEach((o) => canvas.remove(o));
            addSafeZone();
            didRestore = true;
          }
        } catch (e) { console.warn('savedJSON restore failed', e); }
      }
      if (!didRestore) { addSafeZone(); }

      scaleRef.current = canvasW / widthMM;
      historyRef.current = [JSON.stringify(canvas.toJSON(['_isBgImage','_isSafeZone','_isGuideLine','_isGuideText','_isSizeLabel','_isBgPattern','selectable','evented','name']))];
      historyIdxRef.current = 0;
      loadingRef.current = false;

      let vLine: any = null;
      let hLine: any = null;
      const snapPx = 8;
      canvas.on('object:moving', (opt: any) => {
        if (vLine) { canvas.remove(vLine); vLine = null; }
        if (hLine) { canvas.remove(hLine); hLine = null; }
        const obj = opt.target; if (!obj) return;
        const bound = obj.getBoundingRect();
        const cx = bound.left + bound.width / 2; const cy = bound.top + bound.height / 2;
        const cw = canvas.getWidth(); const ch = canvas.getHeight();
        let snappedV = false, snappedH = false;
        if (Math.abs(cx - cw / 2) < snapPx) { obj.set("left", cw / 2 - bound.width / 2 + (obj.left - bound.left)); snappedV = true; }
        if (Math.abs(cy - ch / 2) < snapPx) { obj.set("top", ch / 2 - bound.height / 2 + (obj.top - bound.top)); snappedH = true; }
        const lineColor = (snappedV && snappedH) ? "#4CAF50" : "#ff0000";
        if (snappedV) { const { Line } = require("fabric"); vLine = new Line([cw/2, 0, cw/2, ch], { stroke: lineColor, strokeWidth: 1, strokeDashArray: [5,3], selectable: false, evented: false }); (vLine as any)._isGuideLine = true; canvas.add(vLine); }
        if (snappedH) { const { Line } = require("fabric"); hLine = new Line([0, ch/2, cw, ch/2], { stroke: lineColor, strokeWidth: 1, strokeDashArray: [5,3], selectable: false, evented: false }); (hLine as any)._isGuideLine = true; canvas.add(hLine); }
        canvas.renderAll();
      });
      canvas.on('object:modified', () => { if (vLine) { canvas.remove(vLine); vLine = null; } if (hLine) { canvas.remove(hLine); hLine = null; } canvas.renderAll(); if (!loadingRef.current) { pushHistory(); refreshLayers(); } });
      canvas.on('object:added', (opt: any) => { if (opt.target?._isGuideLine || opt.target?._isSafeZone || opt.target?._isGuideText || opt.target?._isSizeLabel) return; if (!loadingRef.current) { pushHistory(); refreshLayers(); } });
      canvas.on('object:removed', () => { if (!loadingRef.current) { pushHistory(); refreshLayers(); } });
      canvas.on('selection:created', () => refreshLayers());
      canvas.on('selection:updated', () => refreshLayers());
      canvas.on('selection:cleared', () => refreshLayers());

      keyHandler = (e: KeyboardEvent) => {
        const canvas = fcRef.current; if (!canvas) return;
        const tag = (document.activeElement?.tagName || '').toUpperCase();
        if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;
        if ((e.ctrlKey || e.metaKey) && e.code === 'KeyZ' && !e.shiftKey) { e.preventDefault(); if (historyIdxRef.current > 0) { historyIdxRef.current--; loadingRef.current = true; const json = JSON.parse(historyRef.current[historyIdxRef.current]); canvas.loadFromJSON(json).then(() => { canvas.getObjects().forEach((o: any) => { if (o.name === '__bgImage__') { o._isBgImage = true; o.set({ selectable: false, evented: false }); } }); canvas.renderAll(); loadingRef.current = false; refreshLayers(); setHistoryIdx(historyIdxRef.current); }); } }
        if ((e.ctrlKey || e.metaKey) && e.code === 'KeyZ' && e.shiftKey) { e.preventDefault(); if (historyIdxRef.current < historyRef.current.length - 1) { historyIdxRef.current++; loadingRef.current = true; const json = JSON.parse(historyRef.current[historyIdxRef.current]); canvas.loadFromJSON(json).then(() => { canvas.getObjects().forEach((o: any) => { if (o.name === '__bgImage__') { o._isBgImage = true; o.set({ selectable: false, evented: false }); } }); canvas.renderAll(); loadingRef.current = false; refreshLayers(); setHistoryIdx(historyIdxRef.current); }); } }
        if ((e.ctrlKey || e.metaKey) && e.code === 'KeyA') { e.preventDefault(); const { ActiveSelection } = require("fabric"); const objs = canvas.getObjects().filter((o: any) => o.selectable !== false); if (objs.length > 0) { const sel = new ActiveSelection(objs, { canvas }); canvas.setActiveObject(sel); canvas.renderAll(); } }
        if (e.code === 'F1') { e.preventDefault(); setShowShortcuts((p: boolean) => !p); }
        if (e.key === 'Escape') { setShowShortcuts(false); }
        if (e.key === 'Delete' || e.key === 'Backspace') { const obj = canvas.getActiveObject(); if (obj && obj.selectable !== false) { if (obj.type === 'activeselection') { const children = (obj as any)._objects || []; canvas.discardActiveObject(); children.forEach((o: any) => { if (o.selectable !== false) canvas.remove(o); }); canvas.renderAll(); refreshLayers(); } else { canvas.remove(obj); canvas.discardActiveObject(); canvas.renderAll(); } } }
        if ((e.ctrlKey || e.metaKey) && e.code === 'KeyC') { e.preventDefault(); const obj = canvas.getActiveObject(); if (!obj) return; (window as any).__clipboardObjects = obj; const convertImg = async (o: any) => { if ((o.type === 'image' || o instanceof (require('fabric').FabricImage)) && o._element) { try { const tmpC = document.createElement('canvas'); tmpC.width = o._element.naturalWidth || o._element.width || 200; tmpC.height = o._element.naturalHeight || o._element.height || 200; tmpC.getContext('2d')?.drawImage(o._element, 0, 0); return tmpC.toDataURL('image/png'); } catch { return null; } } return null; }; (async () => { if (obj.type === 'activeselection') { const children = (obj as any)._objects || []; const items: any[] = []; for (const o of children) { const dataUrl = await convertImg(o); const json = o.toJSON(['_isBgImage','selectable','evented','name']); if (dataUrl) json._dataUrl = dataUrl; const matrix = obj.calcTransformMatrix(); const point = require('fabric').util.transformPoint({ x: o.left, y: o.top }, matrix); json._absLeft = point.x; json._absTop = point.y; items.push(json); } (window as any).__clipboardJSON = { type: 'activeselection', items }; } else { const dataUrl = await convertImg(obj); const json = obj.toJSON(['_isBgImage','selectable','evented','name']); if (dataUrl) json._dataUrl = dataUrl; json._absLeft = obj.left; json._absTop = obj.top; (window as any).__clipboardJSON = { type: 'single', items: [json] }; } })(); }
        if ((e.ctrlKey || e.metaKey) && e.code === 'KeyV') { e.preventDefault(); canvas.getObjects().slice().forEach((o: any) => { if (o._isGuideLine) canvas.remove(o); }); const srcObj = (window as any).__clipboardObjects; const clipJSON = (window as any).__clipboardJSON; if (srcObj && srcObj.canvas === canvas) { (async () => { const { FabricImage, ActiveSelection } = await import('fabric'); if (srcObj.type === 'activeselection') { const children = (srcObj as any)._objects || []; const cloned: any[] = []; for (const o of children) { if (o.type === 'image' || o instanceof FabricImage) { try { const tmpC = document.createElement('canvas'); tmpC.width = o._element.naturalWidth || o._element.width || 200; tmpC.height = o._element.naturalHeight || o._element.height || 200; tmpC.getContext('2d')?.drawImage(o._element, 0, 0); const img = await FabricImage.fromURL(tmpC.toDataURL('image/png')); img.set({ left: o.left + 15, top: o.top + 15, scaleX: o.scaleX, scaleY: o.scaleY, angle: o.angle }); cloned.push(img); } catch {} } else { const c = await o.clone(); c.set({ left: o.left + 15, top: o.top + 15 }); cloned.push(c); } } cloned.forEach(c => canvas.add(c)); if (cloned.length > 1) { const sel = new ActiveSelection(cloned, { canvas }); canvas.setActiveObject(sel); } else if (cloned.length === 1) { canvas.setActiveObject(cloned[0]); } } else { if (srcObj.type === 'image' || srcObj instanceof FabricImage) { try { const tmpC = document.createElement('canvas'); tmpC.width = srcObj._element.naturalWidth || srcObj._element.width || 200; tmpC.height = srcObj._element.naturalHeight || srcObj._element.height || 200; tmpC.getContext('2d')?.drawImage(srcObj._element, 0, 0); const img = await FabricImage.fromURL(tmpC.toDataURL('image/png')); img.set({ left: srcObj.left + 15, top: srcObj.top + 15, scaleX: srcObj.scaleX, scaleY: srcObj.scaleY, angle: srcObj.angle }); canvas.add(img); canvas.setActiveObject(img); } catch {} } else { const c = await srcObj.clone(); c.set({ left: srcObj.left + 15, top: srcObj.top + 15 }); canvas.add(c); canvas.setActiveObject(c); } } canvas.renderAll(); refreshLayers(); })(); return; } if (clipJSON && clipJSON.items) { (async () => { const { FabricImage, ActiveSelection, util } = await import('fabric'); const cloned: any[] = []; for (const item of clipJSON.items) { if (item._dataUrl) { try { const img = await FabricImage.fromURL(item._dataUrl); img.set({ left: (item._absLeft || item.left || 50) + 15, top: (item._absTop || item.top || 50) + 15, scaleX: item.scaleX || 1, scaleY: item.scaleY || 1, angle: item.angle || 0 }); cloned.push(img); } catch {} } else { try { const objs = await util.enlivenObjects([item]); if (objs[0]) { objs[0].set({ left: (item._absLeft || item.left || 50) + 15, top: (item._absTop || item.top || 50) + 15 }); cloned.push(objs[0]); } } catch {} } } cloned.forEach(c => canvas.add(c)); if (cloned.length > 1) { const sel = new ActiveSelection(cloned, { canvas }); canvas.setActiveObject(sel); } else if (cloned.length === 1) { canvas.setActiveObject(cloned[0]); } canvas.renderAll(); refreshLayers(); })(); } }
        if ((e.ctrlKey || e.metaKey) && e.code === 'KeyX') { e.preventDefault(); const obj = canvas.getActiveObject(); if (!obj) return; const convertImg = async (o: any) => { if ((o.type === 'image' || o instanceof (require('fabric').FabricImage)) && o._element) { try { const tmpC = document.createElement('canvas'); tmpC.width = o._element.naturalWidth || o._element.width || 200; tmpC.height = o._element.naturalHeight || o._element.height || 200; tmpC.getContext('2d')?.drawImage(o._element, 0, 0); return tmpC.toDataURL('image/png'); } catch { return null; } } return null; }; (async () => { if (obj.type === 'activeselection') { const children = (obj as any)._objects || []; const items: any[] = []; for (const o of children) { const dataUrl = await convertImg(o); const json = o.toJSON(['_isBgImage','selectable','evented','name']); if (dataUrl) json._dataUrl = dataUrl; const matrix = obj.calcTransformMatrix(); const point = require('fabric').util.transformPoint({ x: o.left, y: o.top }, matrix); json._absLeft = point.x; json._absTop = point.y; items.push(json); } (window as any).__clipboardJSON = { type: 'activeselection', items }; (window as any).__clipboardObjects = null; const toRemove = [...children]; canvas.discardActiveObject(); toRemove.forEach((o: any) => canvas.remove(o)); } else { const dataUrl = await convertImg(obj); const json = obj.toJSON(['_isBgImage','selectable','evented','name']); if (dataUrl) json._dataUrl = dataUrl; json._absLeft = obj.left; json._absTop = obj.top; (window as any).__clipboardJSON = { type: 'single', items: [json] }; (window as any).__clipboardObjects = null; canvas.remove(obj); canvas.discardActiveObject(); } canvas.renderAll(); refreshLayers(); })(); }
        if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) { const obj = canvas.getActiveObject(); if (!obj) return; e.preventDefault(); const step = (e.ctrlKey || e.metaKey) ? 1 : 5; if (e.key === 'ArrowUp') obj.set('top', obj.top - step); if (e.key === 'ArrowDown') obj.set('top', obj.top + step); if (e.key === 'ArrowLeft') obj.set('left', obj.left - step); if (e.key === 'ArrowRight') obj.set('left', obj.left + step); obj.setCoords(); canvas.renderAll(); }
        if ((e.ctrlKey || e.metaKey) && e.code === 'KeyD') { e.preventDefault(); const obj = canvas.getActiveObject(); if (!obj || obj.selectable === false) return; if (obj.type === 'image' || obj instanceof (require('fabric').FabricImage)) { const tmpC = document.createElement('canvas'); tmpC.width = obj._element?.naturalWidth || obj._element?.width || 200; tmpC.height = obj._element?.naturalHeight || obj._element?.height || 200; tmpC.getContext('2d')?.drawImage(obj._element, 0, 0); (require('fabric').FabricImage).fromURL(tmpC.toDataURL('image/png')).then((img: any) => { img.set({ left: obj.left + 20, top: obj.top + 20, scaleX: obj.scaleX, scaleY: obj.scaleY, angle: obj.angle }); canvas.add(img); canvas.setActiveObject(img); canvas.renderAll(); refreshLayers(); }); } else { obj.clone().then((c: any) => { c.set({ left: obj.left + 20, top: obj.top + 20 }); canvas.add(c); canvas.setActiveObject(c); canvas.renderAll(); refreshLayers(); }); } }
        if ((e.ctrlKey || e.metaKey) && e.code === 'KeyG') { e.preventDefault(); setShowGrid((p: boolean) => !p); }
      };
      document.addEventListener('keydown', keyHandler);
      const wheelHandler = (opt: any) => { const e = opt.e as WheelEvent; if (e.ctrlKey || e.metaKey) { e.preventDefault(); e.stopPropagation(); const delta = e.deltaY > 0 ? -10 : 10; const newZoom = Math.max(25, Math.min(400, zoomRef.current + delta)); applyZoom(newZoom); } };
      canvas.on('mouse:wheel', wheelHandler);
      autoSaveRef.current = setInterval(() => { const c = fcRef.current; if (!c) return; try { const json = c.toJSON(['_isBgImage','_isSafeZone','_isGuideLine','_isGuideText','_isSizeLabel','_isBgPattern','selectable','evented','name']); localStorage.setItem('panelEditor_autoSave_' + panelId, JSON.stringify(json)); } catch {} }, 10000);
      beforeUnloadRef.current = (e: BeforeUnloadEvent) => { e.preventDefault(); };
      window.addEventListener('beforeunload', beforeUnloadRef.current);
      pasteHandlerRef.current = async (e: ClipboardEvent) => { const items = e.clipboardData?.items; if (!items) return; for (let i = 0; i < items.length; i++) { if (items[i].type.indexOf('image') !== -1) { e.preventDefault(); const blob = items[i].getAsFile(); if (!blob) continue; const reader = new FileReader(); reader.onload = async () => { const dataUrl = reader.result as string; const { FabricImage } = await import('fabric'); const img = await FabricImage.fromURL(dataUrl); const c = fcRef.current; if (!c) return; const maxW = c.getWidth() * 0.8; const maxH = c.getHeight() * 0.8; const sc = Math.min(maxW / (img.width || 1), maxH / (img.height || 1), 1); img.set({ left: 50, top: 50, scaleX: sc, scaleY: sc }); c.add(img); c.setActiveObject(img); c.renderAll(); refreshLayers(); }; reader.readAsDataURL(blob); break; } } };
      wrapperRef.current?.addEventListener('paste', pasteHandlerRef.current);
      refreshLayers();
    };
    boot();
    return () => {
      disposed = true;
      if (keyHandler) document.removeEventListener('keydown', keyHandler);
      if (autoSaveRef.current) clearInterval(autoSaveRef.current);
      if (beforeUnloadRef.current) window.removeEventListener('beforeunload', beforeUnloadRef.current);
      if (pasteHandlerRef.current && wrapperRef.current) wrapperRef.current.removeEventListener('paste', pasteHandlerRef.current);
      const c = fcRef.current; if (c) { c.dispose(); fcRef.current = null; }
    };
  }, [panelId, savedJSON]);
