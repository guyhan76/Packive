
  const pushHistory = useCallback(() => {
    const c = fcRef.current; if (!c) return;
    const json = JSON.stringify(c.toJSON(['_isBgImage','_isSafeZone','_isGuideLine','_isGuideText','_isSizeLabel','_isBgPattern','selectable','evented','name']));
    const arr = historyRef.current;
    if (historyIdxRef.current < arr.length - 1) arr.splice(historyIdxRef.current + 1);
    arr.push(json); if (arr.length > 50) arr.shift();
    historyIdxRef.current = arr.length - 1; setHistoryIdx(historyIdxRef.current);
  }, []);

  const undo = useCallback(() => { const c = fcRef.current; if (!c) return; if (historyIdxRef.current > 0) { historyIdxRef.current--; loadingRef.current = true; const json = JSON.parse(historyRef.current[historyIdxRef.current]); c.loadFromJSON(json).then(() => { c.getObjects().forEach((o: any) => { if (o.name === '__bgImage__') { o._isBgImage = true; o.set({ selectable: false, evented: false }); } }); c.renderAll(); loadingRef.current = false; refreshLayers(); setHistoryIdx(historyIdxRef.current); }); } }, [refreshLayers]);
  const redo = useCallback(() => { const c = fcRef.current; if (!c) return; if (historyIdxRef.current < historyRef.current.length - 1) { historyIdxRef.current++; loadingRef.current = true; const json = JSON.parse(historyRef.current[historyIdxRef.current]); c.loadFromJSON(json).then(() => { c.getObjects().forEach((o: any) => { if (o.name === '__bgImage__') { o._isBgImage = true; o.set({ selectable: false, evented: false }); } }); c.renderAll(); loadingRef.current = false; refreshLayers(); setHistoryIdx(historyIdxRef.current); }); } }, [refreshLayers]);

  const del = useCallback(() => { const c = fcRef.current; if (!c) return; const obj = c.getActiveObject(); if (obj && obj.selectable !== false) { if (obj.type === 'activeselection') { const children = (obj as any)._objects || []; c.discardActiveObject(); children.forEach((o: any) => { if (o.selectable !== false) c.remove(o); }); c.renderAll(); refreshLayers(); } else { c.remove(obj); c.discardActiveObject(); c.renderAll(); } } }, []);

  const handleExport = useCallback((format: 'png' | 'svg' | 'pdf') => {
    const c = fcRef.current; if (!c) return;
    const guides: any[] = [];
    c.getObjects().forEach((o: any) => { if (o._isSafeZone || o._isGuideLine || o._isGuideText || o._isSizeLabel || o._isBgPattern) guides.push(o); });
    guides.forEach(g => c.remove(g)); c.renderAll();
    if (format === 'png') { const dataUrl = c.toDataURL({ format: 'png', multiplier: exportScale }); const link = document.createElement('a'); link.download = panelId + '_' + exportScale + 'x.png'; link.href = dataUrl; link.click(); }
    else if (format === 'svg') { const svg = c.toSVG(); const blob = new Blob([svg], { type: 'image/svg+xml' }); const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.download = panelId + '.svg'; link.href = url; link.click(); URL.revokeObjectURL(url); }
    else if (format === 'pdf') { const dataUrl = c.toDataURL({ format: 'png', multiplier: exportScale }); const w = c.getWidth() * exportScale; const h = c.getHeight() * exportScale; import('jspdf').then(({ jsPDF }) => { const pdf = new jsPDF({ orientation: w > h ? 'landscape' : 'portrait', unit: 'px', format: [w, h] }); pdf.addImage(dataUrl, 'PNG', 0, 0, w, h); pdf.save(panelId + '.pdf'); }).catch(() => alert('PDF export requires jspdf')); }
    guides.forEach(g => c.add(g)); c.renderAll();
  }, [panelId, exportScale]);

  const handleSavePanel = useCallback(() => {
    const c = fcRef.current; if (!c) return;
    const json = JSON.stringify(c.toJSON(['_isBgImage','_isSafeZone','_isGuideLine','_isGuideText','_isSizeLabel','_isBgPattern','selectable','evented','name']));
    const guides: any[] = [];
    c.getObjects().forEach((o: any) => { if (o._isSafeZone || o._isGuideLine || o._isGuideText || o._isSizeLabel) guides.push(o); });
    guides.forEach(g => c.remove(g)); c.renderAll();
    const thumb = c.toDataURL({ format: 'png', multiplier: 0.3 });
    guides.forEach(g => c.add(g)); c.renderAll();
    onSave(panelId, json, thumb);
  }, [panelId, onSave]);

  const addText = useCallback((content?: string, opts?: any) => {
    const c = fcRef.current; if (!c) return;
    const { IText } = require('fabric');
    const text = new IText(content || 'Text', { left: c.getWidth() / 2 - 30, top: c.getHeight() / 2 - 15, fontSize: opts?.fontSize || fSize, fill: opts?.fill || color, fontFamily: opts?.fontFamily || selectedFont, ...opts });
    c.add(text); c.setActiveObject(text); c.renderAll(); refreshLayers();
  }, [fSize, color, selectedFont, refreshLayers]);

  const addShape = useCallback((type: string) => {
    const c = fcRef.current; if (!c) return;
    const { Rect, Circle, Triangle, Line: FLine, Polygon, Ellipse } = require('fabric');
    const cx = c.getWidth() / 2; const cy = c.getHeight() / 2;
    let shape: any;
    if (type === 'rect') shape = new Rect({ left: cx-40, top: cy-30, width: 80, height: 60, fill: color, rx: 0, ry: 0 });
    else if (type === 'roundrect') shape = new Rect({ left: cx-40, top: cy-30, width: 80, height: 60, fill: color, rx: 10, ry: 10 });
    else if (type === 'circle') shape = new Circle({ left: cx-30, top: cy-30, radius: 30, fill: color });
    else if (type === 'ellipse') shape = new Ellipse({ left: cx-30, top: cy-20, rx: 40, ry: 25, fill: color });
    else if (type === 'triangle') shape = new Triangle({ left: cx-30, top: cy-30, width: 60, height: 60, fill: color });
    else if (type === 'line') shape = new FLine([cx-40, cy, cx+40, cy], { stroke: color, strokeWidth: 3, fill: '' });
    else if (type === 'dashed') shape = new FLine([cx-40, cy, cx+40, cy], { stroke: color, strokeWidth: 3, strokeDashArray: [10,5], fill: '' });
    else if (type === 'dotted') shape = new FLine([cx-40, cy, cx+40, cy], { stroke: color, strokeWidth: 3, strokeDashArray: [2,4], fill: '' });
    else if (type === 'arrow') { shape = new FLine([cx-40, cy, cx+40, cy], { stroke: color, strokeWidth: 3, fill: '' }); }
    else if (type === 'diamond') { const s = 30; shape = new Polygon([{x:cx,y:cy-s},{x:cx+s,y:cy},{x:cx,y:cy+s},{x:cx-s,y:cy}], { fill: color }); }
    else if (type === 'star') { const pts: {x:number;y:number}[] = []; const spikes = 5; const outerR = 30; const innerR = 15; for (let i = 0; i < spikes * 2; i++) { const r = i % 2 === 0 ? outerR : innerR; const a = (Math.PI / 2 * 3) + (i * Math.PI / spikes); pts.push({ x: cx + Math.cos(a) * r, y: cy + Math.sin(a) * r }); } shape = new Polygon(pts, { fill: color }); }
    else if (type === 'pentagon') { const pts: {x:number;y:number}[] = []; for (let i = 0; i < 5; i++) { const a = (Math.PI / 2 * 3) + (i * 2 * Math.PI / 5); pts.push({ x: cx + Math.cos(a) * 30, y: cy + Math.sin(a) * 30 }); } shape = new Polygon(pts, { fill: color }); }
    else if (type === 'hexagon') { const pts: {x:number;y:number}[] = []; for (let i = 0; i < 6; i++) { const a = i * Math.PI / 3; pts.push({ x: cx + Math.cos(a) * 30, y: cy + Math.sin(a) * 30 }); } shape = new Polygon(pts, { fill: color }); }
    else if (type === 'cross') { shape = new Polygon([{x:cx-10,y:cy-30},{x:cx+10,y:cy-30},{x:cx+10,y:cy-10},{x:cx+30,y:cy-10},{x:cx+30,y:cy+10},{x:cx+10,y:cy+10},{x:cx+10,y:cy+30},{x:cx-10,y:cy+30},{x:cx-10,y:cy+10},{x:cx-30,y:cy+10},{x:cx-30,y:cy-10},{x:cx-10,y:cy-10}], { fill: color }); }
    if (shape) { c.add(shape); c.setActiveObject(shape); c.renderAll(); refreshLayers(); }
  }, [color, refreshLayers]);

  const addImage = useCallback(() => { fileRef.current?.click(); }, []);
  const onFileChange = useCallback(async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]; if (!file) return;
    const c = fcRef.current; if (!c) return;
    const reader = new FileReader();
    reader.onload = async () => { const dataUrl = reader.result as string; const { FabricImage } = await import('fabric'); const img = await FabricImage.fromURL(dataUrl); const maxW = c.getWidth() * 0.8; const maxH = c.getHeight() * 0.8; const sc = Math.min(maxW / (img.width || 1), maxH / (img.height || 1), 1); img.set({ left: 50, top: 50, scaleX: sc, scaleY: sc }); c.add(img); c.setActiveObject(img); c.renderAll(); refreshLayers(); };
    reader.readAsDataURL(file); e.target.value = '';
  }, [refreshLayers]);

  const toggleDraw = useCallback(() => { const c = fcRef.current; if (!c) return; if (drawMode) { c.isDrawingMode = false; setDrawMode(false); } else { c.isDrawingMode = true; c.freeDrawingBrush.color = color; c.freeDrawingBrush.width = brushSize; setDrawMode(true); setEraserMode(false); } }, [drawMode, color, brushSize]);
  const toggleEraser = useCallback(() => { const c = fcRef.current; if (!c) return; if (eraserMode) { c.isDrawingMode = false; setEraserMode(false); } else { c.isDrawingMode = true; c.freeDrawingBrush.color = '#ffffff'; c.freeDrawingBrush.width = eraserSize; setEraserMode(true); setDrawMode(false); } }, [eraserMode, eraserSize]);

  const handleAiCopy = useCallback(async () => {
    if (!copyProduct.trim()) return; setCopyLoading(true); setCopyResult(null);
    try { const res = await fetch('/api/ai/generate-copy', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ productName: copyProduct, brandName: copyBrand || undefined }) }); const data = await res.json(); if (data.error) throw new Error(data.error); setCopyResult(data); } catch (err: any) { alert('AI Copy failed: ' + err.message); }
    setCopyLoading(false);
  }, [copyProduct, copyBrand]);

  const handleAiReview = useCallback(async () => {
    const c = fcRef.current; if (!c) return; setReviewLoading(true); setReviewResult(null);
    try { const dataUrl = c.toDataURL({ format: 'png', multiplier: 1 }); const res = await fetch('/api/ai/review-design', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ imageData: dataUrl }) }); const data = await res.json(); if (data.error) throw new Error(data.error); setReviewResult(data); } catch (err: any) { alert('AI Review failed: ' + err.message); }
    setReviewLoading(false);
  }, []);

  const handleAiInspire = useCallback(async () => {
    if (!inspirePrompt.trim()) return; setInspireLoading(true); setInspireImage(null);
    try { const res = await fetch('/api/ai/generate-design', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ prompt: inspirePrompt, boxType: panelName, width: widthMM, height: heightMM }) }); const data = await res.json(); if (data.error) throw new Error(data.error); setInspireImage(data.imageUrl || data.url); } catch (err: any) { alert('AI failed: ' + err.message); }
    setInspireLoading(false);
  }, [inspirePrompt, panelName, widthMM, heightMM]);

  const applyInspireToCanvas = useCallback(async () => {
    if (!inspireImage) return; const c = fcRef.current; if (!c) return;
    const { FabricImage } = await import('fabric'); const img = await FabricImage.fromURL(inspireImage);
    const maxW = c.getWidth() * 0.9; const maxH = c.getHeight() * 0.9; const sc = Math.min(maxW / (img.width || 1), maxH / (img.height || 1), 1);
    img.set({ left: c.getWidth()/2, top: c.getHeight()/2, originX:'center', originY:'center', scaleX: sc, scaleY: sc });
    c.add(img); c.setActiveObject(img); c.renderAll(); refreshLayers();
  }, [inspireImage, refreshLayers]);

  const applyCopyToCanvas = useCallback((field: string, value: string) => {
    const c = fcRef.current; if (!c) return;
    const { IText } = require('fabric');
    const sizes: Record<string,number> = { headline: 28, description: 16, slogan: 20, features: 14, backPanel: 12 };
    const text = new IText(value, { left: c.getWidth()/2, top: c.getHeight()/2, originX:'center', originY:'center', fontSize: sizes[field] || 16, fill: '#000000', fontFamily: selectedFont });
    c.add(text); c.setActiveObject(text); c.renderAll(); refreshLayers();
  }, [selectedFont, refreshLayers]);

  const applyTemplate = useCallback(async (tpl: DesignTemplate) => {
    const c = fcRef.current; if (!c) return; setTemplateLoading(tpl.id);
    const F = require('fabric');
    const objs = await tpl.objects(F, c.getWidth(), c.getHeight());
    c.getObjects().filter((o: any) => o.selectable !== false || o._isBgImage).forEach((o: any) => { if (!o._isSafeZone && !o._isGuideLine && !o._isGuideText && !o._isSizeLabel) c.remove(o); });
    objs.forEach((o: any) => c.add(o)); c.renderAll(); refreshLayers(); pushHistory(); setTemplateLoading(null);
  }, [refreshLayers]);

  const handleBgUpload = useCallback(async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]; if (!file) return; const c = fcRef.current; if (!c) return;
    const reader = new FileReader();
    reader.onload = async () => { const dataUrl = reader.result as string; const { FabricImage } = await import('fabric'); const img = await FabricImage.fromURL(dataUrl); img.set({ left:0, top:0, originX:'left', originY:'top', scaleX: c.getWidth()/(img.width||1), scaleY: c.getHeight()/(img.height||1), selectable: false, evented: false, name: '__bgImage__' }); (img as any)._isBgImage = true; const existing = c.getObjects().filter((o:any)=>o._isBgImage && o!==img); existing.forEach((o:any)=>c.remove(o)); c.add(img); c.sendObjectToBack(img); const sz = c.getObjects().filter((o:any)=>o._isSafeZone||o._isGuideText||o._isSizeLabel); sz.forEach((o:any)=>c.sendObjectToBack(o)); c.renderAll(); refreshLayers(); };
    reader.readAsDataURL(file); e.target.value = '';
  }, [refreshLayers]);
  const removeBg = useCallback(() => { const c = fcRef.current; if (!c) return; c.getObjects().filter((o:any)=>o._isBgImage).forEach((o:any)=>c.remove(o)); c.renderAll(); refreshLayers(); }, [refreshLayers]);

  const handleSaveDesign = useCallback(() => {
    const c = fcRef.current; if (!c) return;
    const json = c.toJSON(['_isBgImage','_isSafeZone','_isGuideLine','_isGuideText','_isSizeLabel','_isBgPattern','selectable','evented','name']);
    const blob = new Blob([JSON.stringify(json, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = panelId + '_design.json'; a.click(); URL.revokeObjectURL(url);
  }, [panelId]);

  const handleLoadDesign = useCallback(() => {
    const inp = document.createElement('input'); inp.type = 'file'; inp.accept = '.json';
    inp.onchange = async (e: any) => {
      const file = e.target.files?.[0]; if (!file) return;
      const reader = new FileReader();
      reader.onload = async () => {
        try { const json = JSON.parse(reader.result as string); const c = fcRef.current; if (!c) return;
        await c.loadFromJSON(json); c.getObjects().forEach((o:any)=>{ if(o.name==='__bgImage__'){o._isBgImage=true;o.set({selectable:false,evented:false});} });
        c.renderAll(); refreshLayers(); pushHistory(); } catch(err) { alert('Failed to load design'); }
      };
      reader.readAsText(file);
    };
    inp.click();
  }, [refreshLayers]);
